# XGDataTools Copilot Instructions

## Project Overview

XGDataTools is a Ruby toolkit for working with eXtreme Gammon (XG) file formats used in backgammon analysis software. This project is an AI-assisted translation from the original Python tools created by Michael Petch, with additional Ruby improvements and comprehensive test coverage.

## Domain Context

### eXtreme Gammon & Backgammon
- **eXtreme Gammon**: Professional backgammon analysis software
- **XG files**: Binary file format containing game data, positions, analysis, and rollouts
- **Backgammon terminology**: Understanding of game concepts (positions, cube decisions, rollouts) is helpful
- **File format documentation**: Available at https://www.extremegammon.com/XGformat.aspx

### File Format Characteristics
- **Binary data structures**: Complex nested binary formats with specific byte layouts
- **Compressed segments**: Uses ZLib compression for data efficiency
- **Multiple data types**: Game headers, position data, analysis results, comments
- **Endianness**: Little-endian byte order throughout

## Architecture & Module Organization

### Core Modules

#### `xgutils.rb` - Utility Functions
- **CRC32 calculations**: Stream-based checksum verification
- **Date conversions**: Delphi DateTime ↔ Ruby DateTime conversion
- **String handling**: UTF16 integer arrays to UTF8 strings
- **Binary data utilities**: Low-level data manipulation

#### `xgimport.rb` - File Import System
- **File segmentation**: Breaks XG files into manageable segments
- **Temporary file management**: Safe handling of extracted data
- **Stream processing**: Efficient handling of large binary files
- **Error handling**: Robust error reporting with file context

#### `xgstruct.rb` - Data Structure Classes
- **Hash-based records**: All record types inherit from Hash for flexibility
- **Dynamic method access**: Supports both `obj['key']` and `obj.key` syntax
- **Binary deserialization**: `fromstream()` methods parse binary data
- **Type-specific records**: GameDataFormatHdrRecord, TimeSettingRecord, etc.

#### `xgzarc.rb` - ZLib Archive Handling
- **Compressed data**: Handles ZLib-compressed file segments
- **Archive records**: Structured access to compressed file collections
- **Stream decompression**: Memory-efficient decompression

#### `extractxgdata.rb` - CLI Application
- **Command-line interface**: User-friendly tool for data extraction
- **File processing**: Batch processing of multiple XG files
- **Output management**: Configurable output directories and file naming

## Ruby Conversion Patterns

### From Python to Ruby
This project follows specific patterns when translating Python concepts:

```ruby
# Python dict inheritance → Ruby Hash inheritance
class GameRecord < Hash
  def initialize(**kwargs)
    defaults = { 'Name' => 'Game', 'Type' => 0 }
    super(defaults.merge(kwargs))
  end
end

# Python __getattr__/__setattr__ → Ruby method_missing
def method_missing(method_name, *args)
  if method_name.to_s.end_with?('=')
    self[method_name.to_s.chomp('=')] = args.first
  else
    self[method_name.to_s]
  end
end

# Python struct.unpack → Ruby String#unpack
data = stream.read(12)
values = data.unpack('L<3')  # Little-endian unsigned longs

# Python context managers → Ruby blocks
File.open(filename, 'rb') do |file|
  # Process file
end
```

### Error Handling Patterns
```ruby
# Custom exception classes with context
class XGImport::Error < StandardError
  attr_reader :filename, :error
  
  def initialize(error, filename)
    @error = error
    @filename = filename
    super("XG Import Error processing '#{filename}': #{error}")
  end
end
```

### Binary Data Handling
```ruby
# Stream positioning and reading
def fromstream(stream)
  start_pos = stream.tell
  data = stream.read(RECORD_SIZE)
  
  # Unpack with specific format
  unpacked = data.unpack('L<L<f<')  # Little-endian: uint32, uint32, float
  
  # Restore stream position if needed
  stream.seek(start_pos + RECORD_SIZE)
end
```

## Coding Standards

### Ruby Style Guidelines
- **Modules for namespacing**: Use modules to organize related classes
- **Snake_case naming**: Follow Ruby conventions for methods and variables
- **Explicit returns**: Generally avoid explicit `return` statements
- **String interpolation**: Prefer `"#{var}"` over string concatenation
- **Symbols for keys**: Use strings for Hash keys (maintains Python compatibility)

### Class Design Patterns
```ruby
# Hash inheritance for data records
class DataRecord < Hash
  attr_accessor :custom_attribute
  
  def initialize(**kwargs)
    defaults = default_values
    super(defaults.merge(kwargs))
  end
  
  private
  
  def default_values
    { 'field1' => 0, 'field2' => '' }
  end
end
```

### File I/O Patterns
```ruby
# Binary file reading with proper encoding
File.open(filename, 'rb') do |file|
  file.binmode
  data = file.read(size)
  # Process binary data
end

# Temporary file creation
temp = Tempfile.new(['prefix', '.ext'])
temp.binmode
temp.write(data)
temp.rewind
```

## Testing Standards

### Test Organization
- **Minitest framework**: Use minitest for all testing
- **One test file per module**: `test_xgutils.rb`, `test_xgstruct.rb`, etc.
- **Comprehensive coverage**: Aim for high line and branch coverage
- **Edge case testing**: Test boundary conditions and error cases

### Test Patterns
```ruby
class TestXGUtils < Minitest::Test
  include TestHelper
  
  def test_method_with_valid_input
    result = XGUtils.method(valid_input)
    assert_equal expected_result, result
  end
  
  def test_method_with_edge_case
    assert_raises(StandardError) do
      XGUtils.method(invalid_input)
    end
  end
  
  def test_hash_like_behavior
    obj = DataRecord.new
    assert_hash_like_behavior(obj, 'key', 'value')
  end
end
```

### Test Helper Usage
```ruby
# Use test helpers for common operations
def test_stream_processing
  data = generate_test_bytes(100)
  stream = mock_stream_with_data(data)
  
  result = process_stream(stream)
  assert_not_nil result
end
```

## Dependencies & Environment

### Standard Library Only
- **No external gems**: Project uses only Ruby standard library
- **Exception**: SimpleCov for test coverage (development dependency)
- **Core libraries**: `zlib`, `date`, `tempfile`, `fileutils`, `optparse`

### Ruby Version Compatibility
- **Target Ruby 3.0+**: Use modern Ruby features appropriately
- **Backward compatibility**: Consider Ruby 2.7+ where possible

## Documentation Standards

### Code Documentation
```ruby
# Clear method documentation with examples
module XGUtils
  # Convert Delphi DateTime to Ruby DateTime
  # Delphi uses days since Dec 30, 1899
  # 
  # @param delphi_datetime [Float] Delphi datetime value
  # @return [DateTime] Ruby DateTime object
  def self.delphidatetimeconv(delphi_datetime)
    # Implementation
  end
end
```

### README Updates
- **Keep documentation current**: Update relevant README files for changes
- **Usage examples**: Provide clear examples for new functionality
- **Module descriptions**: Maintain accurate module descriptions

## Copyright & Licensing

### License Compliance
- **LGPL v3**: Project is licensed under GNU Lesser General Public License v3
- **Copyright preservation**: Maintain original Michael Petch copyright notices
- **Attribution**: Credit original Python implementation

### Header Template
```ruby
#
#   filename.rb - Description
#   Copyright (C) 2013,2014  Michael Petch <mpetch@gnubg.org>
#                                          <mpetch@capp-sysware.com>
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU Lesser General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
```

## Development Workflow

### Adding New Features
1. **Understand the domain**: Research backgammon/XG file format concepts
2. **Check Python original**: Reference original Python implementation
3. **Follow Ruby patterns**: Use established conversion patterns
4. **Write tests first**: Implement comprehensive test coverage
5. **Update documentation**: Keep README files current

### Binary Data Debugging
```ruby
# Helpful debugging techniques
def debug_binary_data(data)
  puts "Data length: #{data.length}"
  puts "Hex dump: #{data.unpack('H*').first}"
  puts "Bytes: #{data.unpack('C*').inspect}"
end
```

### Performance Considerations
- **Stream processing**: Use streaming for large files
- **Memory efficiency**: Avoid loading entire files into memory
- **Chunked reading**: Process data in manageable chunks

## Common Pitfalls & Solutions

### Binary Data Issues
- **Endianness**: Always specify little-endian (`<`) in pack/unpack formats
- **String encoding**: Use `binmode` for binary file operations
- **Null termination**: Handle null-terminated strings properly

### Hash vs Object Behavior
```ruby
# Support both access patterns
def method_missing(method_name, *args)
  if method_name.to_s.end_with?('=')
    key = method_name.to_s.chomp('=')
    self[key] = args.first
  elsif has_key?(method_name.to_s)
    self[method_name.to_s]
  else
    super
  end
end
```

### Error Context
```ruby
# Always provide meaningful error context
begin
  process_file(filename)
rescue => e
  raise Error.new("Failed to process #{filename}: #{e.message}", filename)
end
```

This project represents a faithful Ruby translation of specialized backgammon analysis tools. Understanding the domain context, following established patterns, and maintaining comprehensive test coverage are key to successful contributions.